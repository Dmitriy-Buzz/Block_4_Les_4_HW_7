
# isEmpty - проверка стека на пустоту. Метод возвращает True или False.
# push - добавляет новый элемент на вершину стека. Метод ничего не возвращает.
# pop - удаляет верхний элемент стека. Стек изменяется. Метод возвращает верхний элемент стека
# peek - возвращает верхний элемент стека, но не удаляет его. Стек не меняется.
# size - возвращает количество элементов в стеке.

# Используя стек из задания 1 необходимо решить задачу на проверку сбалансированности скобок.
# Сбалансированность скобок означает, что каждый открывающий символ имеет соответствующий ему закрывающий,
# и пары скобок правильно вложены друг в друга.
# Пример сбалансированных последовательностей скобок:
#
# (((([{}]))))
# [([])((([[[]]])))]{()}
# {{[()]}}
# Несбалансированные последовательности:
#
# }{}
# {{[(])]}}
# [[{())}]
# Программа ожидает на вход строку со скобками. На выход сообщение: "Сбалансированно",
# если строка корректная, и "Несбалансированно", если строка составлена неверно.



simple_list = [1,2,3]

class Stack:

    def __init__(self, stack):
        self.stack = stack

    def isEmpty(self):
        if len(self.stack) == 0:
            print(f'Стек пустой: {True}')
        else: print(f'Кол-во элементов в стеке: {len(self.stack)} {False}')

    def push(self, new_element):
        print(f'Кол-во элементов в списке:{len(self.stack)}')
        self.stack.insert(0, f'{new_element}')
        print(f'Элемент: {new_element} добавлен в начало списка, кол-во элементов в списке: {len(self.stack)}')

    def pop(self):
        print(f'Кол-во элементов в списке:{len(self.stack)}')
        print(f'Элемент {self.stack[0]} удален')
        f_el = self.stack[0]
        del self.stack[0]
        print(f'Кол-во элементов в списке: {len(self.stack)}')
        return f_el


    def peek(self):
        print(f'Верхний элемент списка: {self.stack[0]}')
        return self.stack[0]

    def size(self):
        print(f'Кол-во элементов в списке: {len(self.stack)}')
        return len(self.stack)

main = Stack(simple_list)
main.size()
